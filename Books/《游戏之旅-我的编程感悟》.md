## 《游戏之旅-我的编程感悟》

**程序=算法+数据结构**

**常见的层次按以下表递增：**
O(log n) < O(n) < O(nlog₂n) < O(n²) < O(nⁿ¹) < O(2ⁿ¹) < O(n1ⁿ) < O(n!)

1. 现代编程语言，不再重视程序逻辑的实现和数据的简单描述方法，而注重问题的分化、类层次的设计、模块的封装。

### 算法，程序的灵魂

#### 数据结构，数组、链表、字典、集合、栈、队列等

这里不一一列举，还包括各种树、图等

#### 搜索算法

1. **盲目搜索策略**：
   1. **广度优先搜索**（需要消耗大量的内存）
   2. **深度优先搜索**（消耗最少的内存，消耗教多的时间）
   3. **迭代加深搜索**。即定一个搜索树的最大深度，做深度优先搜索，如果无法找到解，就加大最大深度，重新来。典型的时间换空间策略
2. **启发式搜索**：
   1. **A*算法**（F=G+H），作为游戏程序员最熟知的（本Git中有用Python实现）。最差的情况，占用的时间、空间和广度优先搜索相当，而绝大部分情况要明显好
   2. **A算法**，采用不遵从如A*的估价函数的启发式搜索。典型的例子，我们认为通过障碍的代价比绕过障碍之地的代价要大，这样在寻路中，就趋向于避开大量障碍
   3. **IDA*算法**，结合A*和迭代加深算法，把搜索过程改为迭代加深，而在搜索过程中忽略掉估价值大于迭代上限的节点，使得速度大大加快。而且在搜索过程中，不需要对待扩展节点排序，使用更加简单
3. **博弈问题**
   1. **Alpha-Beta剪枝**，一种剪枝算法
   2. **SSS*算法**，基于启发式的广度优先算法改版
   3. **MemSS*算法**，在SSS*算法的基础上，限制了内存空间上限，一旦溢出则丢掉一些评估很低的节点
4. **智能算法**（人工智能）
   1. **遗传算法（Genetic Algorithm）**，先把需要解决的问题分解为一个个小的元素，一组元素就构成了对这个问题的一个可能解
   2. **模拟退火算法（Simulated Annealing）**，退火：一种金属热处理方法

