## 《游戏编程模式》

> 难道你真的想要阅读另外一本关于员工记录和银行账户例子的设计模式图书吗？不想要就读本书吧！

### 第一篇：介绍和框架

### 第二篇：回顾GoF的设计模式

### 第三篇：重点，呈现作者认为十分有用的13种设计模式

Q:如果只是想要验证一些游戏想法是否能够正确工作，那么对其精心设计架构就意味着在想法真正显示到屏幕中并得到反馈之前需要花费更多时间

A:原型代码（尽量保证你的原型代码不会变成真正的代码，不然会很糟糕，有一个小方法，利用不同的语言来编写原型代码）

需要清楚，最快编写的代码实现却很少是运行最快的

**Tips:**

1. 抽象和解耦能够使得你的程序开发变得更快和更简单。但是不要过度设计
2. 在开发周期中要对性能进行思考和设计，但是要推迟那些降低灵活性的、底层的、详尽的优化
3. 不要留下烂摊子或者暗雷，避免自己及他人踩坑
4. 如果要删除代码，就直接删，不要浪费时间用来整理
5. 若要做一些有趣的玩意，就乐在其中！

#### 状态模式

> 整个状态分为：状态、输入、转换（Unity的状态机应该用的就是状态模式，而且是最典型的）

**有限状态机在如下条件时会非常有用：**

1. 你有一个游戏实体，它的行为基于它的内部状态而改变

2. 这些状态被严格划分为相对数量较小的集合

3. 游戏实体随着时间的变化会响应用户输入和一些游戏事件

* 下推状态机，利用栈的原理，使得当前状态处于栈顶，当当前状态播放完毕之后可以很方便的回归到之前的状态
* 层次状态机，利用继承的方式，将状态划分为多个层次，各个层次处理各自的事情
* 并发状态机，定义多个有限状态机同时处理，并发运行

#### 沙盒模式

> 一个基类定义了一个抽象的沙盒方法和一些预定义的操作集合。通过将它们设置为受保护的状态以确保它们仅供子类使用。每个派生出的沙盒子类根据父类提供的操作来实现沙盒函数。

1. 创建一个继承自Superpower的新类
2. 覆写沙盒函数activeate()
3. 通过调用Superpower提供的保护函数来实现新类方法的函数体

**用法**：有点像项目中的存储方法或者attrblock类，这些类方法只用于子类的使用，而不用被外部所知

#### 类型对象

> 旨在将“类型”的定义从严格生硬的代码语言转移到灵活却弱化了行为的内存对象中。

A：围绕的问题是如何在不同对象之间共享数据

S：

	1. 原型模式 
 	2. 类型模式和享元模式，实现对象之间共享数据
 	3. 类型对象模式（重点在于组织性和灵活性），利用继承和组合，并可以使用工厂模式。

#### 组件模式

> 形如组合，将一个庞大的类解耦，使得他们抽象为个体类，并在需要用到的地方对这些个体类实例进行组合完成需求。使用过Unity3D引擎应该对组合会比较了解，其GameObject类是完全围绕组件来设计的

1. 进行代码解耦，更加抽象
2. 各个实例之间进行组合
3. 个体更抽象，组合更复杂

#### 事件队列

> 此模式又叫“发布-订阅”，队列式（先进先出）对事件进行处理，并且对事件的处理方式上有点像观察者模式

* 单播队列：每个事件一个监听者
* 广播队列：每个事件多个监听者
* 工作队列：多个监听者，但此事件只会投递到一个监听器中，可能是择优，可能是随机

1. 切记丢进队列的事件不应存在循环引用，因为很可能造成死循环
2. 此队列应该是可存储的（存盘）
3. 多线程多进程入队出队时必须加锁
4. 无GC的语言，对事件实例的生存周期需要处理
   1. 转移所有权，发送者不再拥有它，接受者取走所有权并负责释放
   2. 共享所有权，当无引用时才被释放
   3. 队列用于它，接受者处理完之后告诉队列，队列负责释放

#### 服务定位器

> 类似于回合制‘’手游神武3‘’中活动的初始化，因为回合制活动众多，所以一般会选择将活动类全部初始化，并置于一个字典中管理，这个字典key为活动名（English String）,当我们需要某个活动时，直接调用这个字典就能够成功获取，获取不到则返回None

1. 需要在所有使用者之前初始化这个服务定位器中的元素
2. 能够快速找到所需服务
3. 服务不存在会返回None，让使用者进行容错处理

#### 优化型模式

1. 数据局部性
2. 脏标记模型
3. 对象池
4. 空间分区

#### 优化 | 数据局部性

> 为了保证数据不过于影响性能，所以使得数据能够实现缓存机制，来加快CPU对数据的读取

1. 连续数组
2. 对象池技术
3. LRU机制，将热数据存于内存，冷数据从数据库中读，保证大部分性能（数据结构：双向链表+HashMap）

### 脏标记模式

> 一组数据中，如果每个数据改变时就需要刷新本组数据，那刷新的频率会过大。使用脏标记，仅当有需要该组数据或者达到一定时间（脏标记一般伴随定时器）切有脏标记则进行刷新切清除标记。否则使用缓存。

1. 涉及到计算、同步
2. 数据存盘是个很好的例子，例如背包中，不可能每个数据发生改变就得存盘一次，这个开销会很大，此时一般利用脏标记模式，当刷新时，如果有脏标记才存盘
3. 此模式把耗时的工作推迟到真正需要时才进行
4. 追踪粒度越小，效率越高。例如一个组数据，而粒度只需要改动一个数据中的一个小块，那效率肯定高

### 对象池

> 当大量相同类型实例需要被重用时推荐使用（例如子弹实例）

1. 避免因在不同上下文中使用相同对象而导致的重复内存使用
2. 对象池中的对象在其生命周期不存在因为被共享而引致异常
3. 对象池必须是有限的，保证内存不会溢出
4. 最好有设计对象池中的对象如果长时间未被使用，因清理

### 空间分区

> 这是一个用来存储活跃的、移动的游戏对象以及静态图像和游戏世界的几何形状等对象的常见模式
> Q：如何快速高效的查找移动对象附近的所有对象

1. 网格【Grid(spatial_index)】
2. 四叉树
3. 二叉空间分割
4. k-dimensional树
5. 层次包围盒


