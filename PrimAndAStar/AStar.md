### A*算法

#### 原理：F(n) = G(n) + H(n)

> 这里的G代表的是起始点到当前点(n)的实际值，H代表的是当前点到目标点最佳路径的估算值

##### 我们以D(n)表达当前点n到目标点的实际距离，那么H(n)的选取大致有如下三种情况：

1. 如果H(n)<D(n)到目标状态的实际距离，这种[情况](https://baike.baidu.com/item/情况)下，搜索的点数多，搜索范围大，效率低。但能得到最优解。
2. 如果H(n)=D(n)，即距离估计H(n)等于最短距离，那么搜索将严格沿着最短路径进行， 此时的搜索效率是最高的。
3. 如果 H(n)>D(n)，搜索的点数少，搜索范围小，效率高，但不能保证得到最优解。

##### 那根据上述公式，然后以一下的思路就可以完成一个原始的A*算法

##### 步骤：

###### 1.将起始点加入到开启列表

###### 2.重复以下工作：

1. 寻找开启列表中F值最小的点，设置为当前点
2. 将其切换到关闭列表中
3. 对当前点临近点A们进行F值计算
   * 如果A不可通过或者已经在关闭列表中，略过
   * 如果A不在开启列表中，则添加进去，并将A的父节点指向当前点，并计算F,G,H值
   * 如果A已经在开启列表中，用G值作为参考检测新的路径是否更好，更低的G值意味着更好的路线。如果G值要小于之前G值，则让A点的父节点改成当前点，并重新计算A的F,G,H值。如果开启列表有排序，此时需要重新排序（这里的G值计算应该是当前点的G值加上当前点到A点的G值，并与之前的G值比较）
   * 停止，当
     *  把目标格加入到关闭列表中，此时路线已被找到
     *  没有找到目标格，开启列表已经空了。这时候路径不存在

###### 3.保存路径，从目标格开始，往上遍历父节点，即是我们需要的路径

