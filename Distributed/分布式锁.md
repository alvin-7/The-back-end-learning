## 分布式锁

1. try...finally 结构，finally中释放锁，保证无论try中逻辑是否正确，锁都能够被释放
2. 使用redis.set(key, value, ex=xx, nx=True)来生成一把有超时时间的锁
3. 为了保证每个开启锁和释放锁都正确，锁的值应该为客户端唯一标识值，且需要根据该值释放锁（如果锁的值不是该值，不应该释放）
4. 当成功生成锁之后，开启另外一个守护线程，该线程每隔1/3锁时间来检测锁是否还存在，如果存在，则延长锁时间，保证我们的逻辑在任何情况下，都能够被执行完，并能够正确释放锁

### 存在问题

#### 1.单点故障主从切换带来的两个客户端同时持有锁的问题

**问题描述**
   生产中redis一般是主从模式，主节点挂掉时，从节点会取而代之，客户端上却并没有明显感知。原先第一个客户端在主节点中申请成功了一把锁，但是这把锁还没有来得及同步到从节点，主节点突然挂掉了。然后从节点变成了主节点，这个新的节点内部没有这个锁，所以当另一个客户端过来请求加锁时，立即就批准了。这样就会导致系统中同样一把锁被两个客户端同时持有，不安全性由此产生。

**解决方案**

1. 使用RedLock算法
2. zookeeper(不使用Redis实现，效率会降低，但是能够保证数据一致性)

#### 2.RedLock算法

**算法核心**
使用**N个完全独立、没有主从关系的Redis master节点以保证他们大多数情况下都不会同时宕机**，N一般为奇数。

1. 获取当前时间（单位是毫秒）。 
2. 轮流用相同的key和随机值在N个节点上请求锁，在这一步里，客户端在每个master上请求锁时，会有一个和总的锁释放时间相比小的多的超时时间。比如如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间可能是5-50毫秒的范围，这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间，如果一个master节点不可用了，我们应该尽快尝试下一个master节点。 
3. 客户端计算第二步中获取锁所花的时间，只有当客户端在大多数master节点上成功获取了锁（(N/2) +1），而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了。 
4. 如果锁获取成功了，那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。 
5. 如果锁获取失败了，不管是因为获取成功的锁不超过一半（N/2+1)还是因为总消耗时间超过了锁释放时间，客户端都会到每个master节点上释放锁，即便是那些他认为没有获取成功的锁。